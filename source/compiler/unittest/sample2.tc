type WorkerInput = variant {
    DownloadFile(url: string),
    Exit()
}

type WorkerOutput = variant {
    Ok(tmpPath: string),
    Error(code: u32)
}

type Worker = process<WorkerInput, WorkerOutput>(num: u32, renderingProcess: NotificationWorker) {
    print("hi")
}

type NotificationWorker = process<WorkerOutput, u32>(x: i32, y: i32) {
    fn receive(input: WorkerOutput) {
        match input {
            WorkerOutput.Ok(tmpPath) {
                DisplayGUIPopUP("success", "Download complete")
            }
            WorkerOutput.Error(code) {
                DisplayGUIPopUP("success", "Download Failed.")
            }
        }
    }
}

fn main() -> void {
    let okResults: struct {worker: Worker, response: ProcessResponse}[] = []
    let errorResults: struct {worker: Worker, response: ProcessResponse}[] = []
    let notificationGUI: NotificationWorker = spawn ::NotificationWorker()

    let processes: Worker[] = []
    for let i: u32 = 0; i < 1000; i = i + 1 {
        let listener: fn(input: WorkerOutput) =
            fn(input: WorkerOutput) {
                 match input {
                    WorkerOutput.Ok(tmpPath) {
                        okResults.push({worker: processes[i], response: input})
                    }
                    WorkerOutput.Error(code) {
                        errorResults.push({worker: processes[i], response: input})
                    }
            }
        }
        processes.push(spawn listener::Worker(i, notificationGUI))
        emit processes[i]::DownloadFile("https://www.google.com")
        emit processes[i]::Exit()
    }
}